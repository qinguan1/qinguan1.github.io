
#### redis过期键的删除策略

1. **立即删除（主动策略）**
**在设置键的同时，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。**
好处是：立即删除能保证内存中数据的最大新鲜度，因为它保证过期键值会在过期后马上被删除，其所占用的内存也会随之释放。
但是坏处是立即删除**对cpu是最不友好**的。因为删除操作会占用cpu的时间，如果刚好碰上了cpu很忙的时候，比如正在做交集或排序等计算的时候，就会给cpu造成额外的压力。而且目前redis事件处理器对时间事件的处理方式–无序链表，查找一个key的时间复杂度为O(n)，所以并不适合用来处理大量的时间事件。

2. **惰性删除（被动策略）**
**放任键过期不管，等到下次被使用的时候，会被检查是否过期，如果过期则删除，没有则返回该键。**
惰性删除的缺点很明显：**浪费内存**，dict字典和expires字典都要保存这个键值的信息。

举个例子，对于一些按时间点来更新的数据，比如log日志，过期后在很长的一段时间内可能都得不到访问，这样在这段时间内就要拜拜浪费这么多内存来存log。这对于性能非常依赖于内存大小的redis来说，是比较致命的。

3. **定时删除（主动策略）**
从上面分析来看，立即删除会短时间内占用大量cpu，惰性删除会在一段时间内浪费内存，所以定时删除是一个**折中**的办法。
定时删除是：**每隔一段时间执行一次删除操作，并通过限制删除操作执行的时长和频率，来减少删除操作对cpu的影响。**
另一方面定时删除也有效的**减少了**因惰性删除带来的内存浪费。

**redis使用的过期键值删除策略是：惰性删除加上定期删除，两者配合使用。**
**好处是服务器可以很好地在合理使用CPU时间和浪费内存空间之间取得平衡**

#### 持久化对过期键的处理

##### RDB

**生成RDB**
执行**SAVEH**命令或者**BGSAVE**生成RDB文件时，会对键进行检查，已过期的键不会被保存到新创建的RDB文件中。

**载入RDB**
1. 如果服务器以**主服务器**模式运行，在载入 RDB 文件时，会对文件中的键进行检查，**过期键不会被载入**。
2. 如果服务器以**从服务器**模式运行，在载入 RDB 文件时，不论文件中的键是否过期**都会被载入**，不过因为主从服务器在进行同步的时候，
从服务器的数据会被清空，所以过期键对载入 RDB 文件的从服务器也不会造成影响

##### AOF

**生成AOF**
当服务器以AOF持久化模式运行时，**已过期但未被惰性删除或定期删除的键不会对 AOF 文件产生影响**。

**AOF重写**
当服务器以AOF持久化模式运行时，如果数据库某个键已过期，但是未被惰性删除或定期删除，那么 AOF 文件**不会**因此产生影响。
当过期键被惰性删除或定期删除，程序会向 AOF 文件**追加一条 DEL 命令**，来表示该键已被删除。
例如：客户端执行过期的键msg：GET msg，那么服务器会执行一下操作：
1. 从数据库中删除 msg
2. 追加一条 DEL msg 命令到 AOF 文件
3. 向执行 GET 命令的客户端返回空回复















