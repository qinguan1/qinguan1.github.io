### 概述：网络七层架构

网络OSI模型图：
![进程的结构图：](https://raw.githubusercontent.com/qinguan1/qinguan1.github.io/main/docs/assets/img/qinguan/网络OSI模型图.png)

七层模型介绍：
1. 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。
2. 数据链路层: 主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。
3. 网络层：主要将从下层接收到的数据进行 IP 地址（例192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。
4. 传输层：传输层向高层提供可靠的端到端的网络数据流服务。可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／IP）协议；
5. 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）
6. 表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））
7. 应用层：OSI 的应用层协议包括文件的传输、访问及管理协议(FTAM) ,以及文件虚拟终端协议(VIP)和公用管理系统信息(CMIP)等; 规定数据的传输协议；

### TCP/IP 原理

#### 概述
TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族
从协议分层模型方面来讲，TCP/IP 由四个层次组成：**网络访问层、网络层、传输层、应用层**

#### 关于TCP
- TCP 提供一种面向连接的、可靠的字节流服务
- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP
- TCP 使用校验和，确认和重传机制来保证可靠传输
- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
####vTCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

#### 四个层次
1. 网络访问层(Network Access Layer)：提供与物理网络的接口。针对传输介质设置数据的格式，根据物理地址实现数据的寻址，对数据在物理网络的传递提供错误控制，**TCP/IP网络访问层大致对应OSI的物理层和数据链路层**。
2. 网络层(Internet Layer)：整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标
3. 传输层(Tramsport Layer-TCP/UDP)：使源端和目的端机器上的对等实体可以进行会话。在这一层定义了两个端到端的协议：**传输控制协议**(TCP，Transmission Control Protocol)和**用户数据报协议**(UDP，User Datagram Protocol)。TCP 是**面向连接**的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有**可靠性保证、流量控制、多路复用、优先权和安全性控制等**功能。UDP 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。
4. 应用层(Application Layer)：虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。

TCP 在**传输之前**会进行三次沟通，一般称为“三次握手”，传完数据**断开**的时候要进行四次沟通，一般称为“四次挥手”
这是由于 TCP 的半关闭造成的

#### 三次握手
第一次握手：主机 A 发送位码为 syn＝1,随机产生 seq number=1234567 的数据包到服务器，主机 B 由 SYN=1 知道，A 要求建立联机；
第二次握手：主机 B 收到请求后要确认联机信息，向 A 发 送 ack number=( 主 机 A 的
seq+1),syn=1,ack=1,随机产生 seq=7654321 的包
第三次握手：主机 A 收到后检查 ack number 是否正确，即第一次发送的 seq number+1,以及位码
ack 是否为 1，若正确，主机 A 会再发送 ack number=(主机 B 的 seq+1),ack=1，主机 B 收到后确认
seq 值与 ack=1 则连接建立成功。

第一次握手([SYN], Seq = x)
建立连接时，客户端发送一个SYN标记的包，Seq初始序列号x，发送完成后**客户端**进入**SYN_SEND**状态。

第二次握手([SYN,ACK], Seq = y, ACK = x + 1)
**服务器**收到syn包，返回确认包(ACK)应答，同时还要发送一个SYN包回去。ACK = x + 1,表示确认收到(客户端发来的Seq值 + 1)，Seq = y, 表示让客户端确认是否能收到。发送完成后**服务端**进入**SYN_RCVD**状态。

第三次握手([ACK], ACK = y + 1)
**客户端**收到服务器的SYN+ACK包，向服务器发送确认包(ACK),ACK = y + 1, 表示确认收到服务器的包（服务端发来的Seq值 + 1）。**客户端**发送完毕后，进入**ESTABLISHED**状态，**服务端**接收到这个包，也进入**ESTABLISHED**状态, TCP握手结束。

**完成三次握手，客户端与服务器端开始传送数据。**

**为什么是三次握手?不是两次或者四次？**

从假设的角度来分析吧，假如是两次握手，会发生什么情况呢? 服务端在发出应答消息后，它根本就不能确认客户端是否接受到消息了，那么这样意味着只有客户端可以向服务端发送数据。
假如是四次握手呢？明明已经保证了一个稳定的传输流了，为什么还要浪费性能再去发一次消息，浪费了性能。
所以三次是最合适的，这里本人只是从个人的角度简单分析，没有从序列等原理的角度去剖析。
































