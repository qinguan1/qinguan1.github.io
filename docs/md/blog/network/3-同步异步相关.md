## 同步异步相关

作者：qinguan
<br/>博客：[https://bugstack.cn](https://bugstack.cn)

> 故不积跬步，无以至千里；不积小流，无以成江海！🌻

### 一、同步和异步

同步和异步从方法调用者角度来看：
- 同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为
- 异步方法调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。如果异步调用需要返回结果，那么当这个异步调用真实完成时，则会通知调用者。异步方法通常会在另外一个线程中“真实”地执行。

### 二、并发和并行

它们都可以表示两个或者多个任务一起执行，但是偏重点有些不同：
- 并发偏重于多个任务 **交替执行**，而多个任务之间有可能还是**串行**的。而并行是真正意义上的“同时执行”。
- 并行的多个任务是真实的同时执行。

实际上，如果系统内只有一个CPU，而使用多进程或者多线程任务，那么真实环境中这些任务**不可能是真实并行**的，毕竟一个CPU一次只能执行一条指令，这种情况下多进程或者多线程就是并发的，而不是并行的（操作系统会不停切换多个任务）。**真实的并行也只可能出现在拥有多个CPU的系统中（比如多核CPU）。**


### 三、临界区

临界区用来表示一种**公共资源或者说是共享数据**，可以被多个线程使用。
在并行程序中，临界区资源是保护的对象

### 四、阻塞和非阻塞

阻塞和非阻塞通常用来形容多线程间的相互影响。
比如一个线程占用了临界区资源，那么其他所有需要这个资源的线程就必须在这个临界区中进行等待。
等待会导致**线程挂起**，这种情况就是**阻塞**。
此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。

### 五、死锁、饥饿、活锁

死锁、饥饿和活锁都属于多线程的**活跃性**问题。

#### 1、死锁

死锁是指两个或两个以上的进程在执行过程中，由于**竞争资源或者由于彼此通信**而造成的一种**阻塞**的现象，若无外力作用，它们都将无法推进下去。

产生死锁的四个必要条件：
- **互斥条件**：一个资源每次只能被一个进程使用。
- **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- **不剥夺条件**：进程已获得的资源，在末使用完之前，不能强行剥夺。
- **循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。

**只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。**

#### 2、饥饿

饥饿是指某一个或者多个线程因为种种原因**无法获得**所需要的资源，导致一直无法执行。
比如它的线程优先级可能太低，而高优先级的线程不断抢占它需要的资源，导致低优先级线程无法工作。

与死锁相比，饥饿还是有可能在未来一段时间内解决的。

#### 3、活锁

活锁指的是：任务或者执行者**没有被阻塞**，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 

**活锁有可能自行解开，死锁则不能**
为解决活锁可以引入一些随机性，例如如果检测到冲突，那么就暂停随机的一定时间进行重试。这回大大减少碰撞的可能性。
典型的例子是以太网的**CSMA/CD检测机制**。
