## 网络七层架构

作者：qinguan
`<br/>`博客：[https://bugstack.cn](https://bugstack.cn)

> 故不积跬步，无以至千里；不积小流，无以成江海！🌻

### 概述：网络七层架构

**网络OSI模型图：**
![网络OSI模型图](https://raw.githubusercontent.com/qinguan1/qinguan1.github.io/main/docs/assets/img/qinguan/网络OSI模型图.png)

七层模型介绍：

1. 物理层：主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由 1、0 转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的模数转换与数模转换）。这一层的数据叫做比特。
2. 数据链路层: 主要将从物理层接收的数据进行 MAC 地址（网卡的地址）的封装与解封装。常把这一层的数据叫做帧。在这一层工作的设备是交换机，数据通过交换机来传输。
3. 网络层：主要将从下层接收到的数据进行 IP 地址（例192.168.0.1)的封装与解封装。在这一层工作的设备是路由器，常把这一层的数据叫做数据包。
4. 传输层：传输层向高层提供可靠的端到端的网络数据流服务。可以理解为：每一个应用程序都会在网卡注册一个端口号，该层就是端口与端口的通信！常用的（TCP／IP）协议；
5. 会话层：通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或或者接受会话请求（设备之间需要互相认识可以是 IP 也可以是 MAC 或者是主机名）
6. 表示层：主要是进行对接收的数据进行解释、加密与解密、压缩与解压缩等（也就是把计算机能够识别的东西转换成人能够能识别的东西（如图片、声音等））
7. 应用层：OSI 的应用层协议包括文件的传输、访问及管理协议(FTAM) ,以及文件虚拟终端协议(VIP)和公用管理系统信息(CMIP)等; 规定数据的传输协议；

### ✒️TCP/IP 原理

#### ✉️ 概述

TCP/IP 协议不是 TCP 和 IP 这两个协议的合称，而是指因特网整个 TCP/IP 协议族
从协议分层模型方面来讲，TCP/IP 由四个层次组成：**网络访问层、网络层、传输层、应用层。**


#### 关于TCP

- TCP 提供一种面向连接的、可靠的字节流服务，由于是流式协议，消息无边界，由此导致了粘包和半包问题
- 在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP
- TCP 使用校验和，确认和重传机制来保证可靠传输
- TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复
- TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制

#### 四个层次

1. 网络访问层(Network Access Layer)：提供与物理网络的接口。针对传输介质设置数据的格式，根据物理地址实现数据的寻址，对数据在物理网络的传递提供错误控制，**TCP/IP网络访问层大致对应OSI的物理层和数据链路层**。
2. 网络层(Internet Layer)：整个体系结构的关键部分，其功能是使主机可以把分组发往任何网络，并使分组独立地传向目标
3. 传输层(Tramsport Layer-TCP/UDP)：使源端和目的端机器上的对等实体可以进行会话。在这一层定义了两个端到端的协议：**传输控制协议**(TCP，Transmission Control Protocol)和**用户数据报协议**(UDP，User Datagram Protocol)。TCP 是**面向连接**的协议，它提供可靠的报文传输和对上层应用的连接服务。为此，除了基本的数据传输外，它还有**可靠性保证、流量控制、多路复用、优先权和安全性控制等**功能。UDP 是面向无连接的不可靠传输的协议，主要用于不需要 TCP 的排序和流量控制等功能的应用程序。
4. 应用层(Application Layer)：虚拟终端协议(TELNET，TELecommunications NETwork)、文件传输协议(FTP，File Transfer Protocol)、电子邮件传输协议(SMTP，Simple Mail Transfer Protocol)、域名服务(DNS，Domain Name Service)、网上新闻传输协议(NNTP，Net News Transfer Protocol)和超文本传送协议(HTTP，HyperText Transfer Protocol)等。

TCP 在**传输之前**会进行三次沟通，一般称为“三次握手”，传完数据**断开**的时候要进行四次沟通，一般称为“四次挥手”
这是由于 TCP 的半关闭造成的

#### 三次握手

**第一次握手([SYN], Seq = x)**
建立连接时，客户端发送一个SYN标记的包，Seq初始序列号x，发送完成后**客户端**进入**SYN_SEND**状态。

**第二次握手([SYN,ACK], Seq = y, ACK = x + 1)**
**服务器**收到syn包，返回确认包(ACK)应答，同时还要发送一个SYN包回去。ACK = x + 1,表示确认收到(客户端发来的Seq值 + 1)，Seq = y, 表示让客户端确认是否能收到。发送完成后**服务端**进入**SYN_RCVD**状态。

**第三次握手([ACK], ACK = y + 1)**
**客户端**收到服务器的SYN+ACK包，向服务器发送确认包(ACK),ACK = y + 1, 表示确认收到服务器的包（服务端发来的Seq值 + 1）。**客户端**发送完毕后，进入**ESTABLISHED**状态，**服务端**接收到这个包，也进入**ESTABLISHED**状态, TCP握手结束。

**完成三次握手，客户端与服务器端开始传送数据。**

**为什么是三次握手?不是两次或者四次？**

从假设的角度来分析吧，假如是两次握手，会发生什么情况呢? 服务端在发出应答消息后，它根本就不能确认客户端是否接受到消息了，那么这样意味着只有客户端可以向服务端发送数据。
假如是四次握手呢？明明已经保证了一个稳定的传输流了，为什么还要浪费性能再去发一次消息，浪费了性能。
所以三次是最合适的，这里本人只是从个人的角度简单分析，没有从序列等原理的角度去剖析。

**TCP 建立连接要进行三次握手，而断开连接要进行四次。**
这是由于 TCP 的半关闭造成的。因为 TCP 连接是全双工的(即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭。这个单
方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。

### HTTP

#### ✉️ 概述

HTTP 是一个无状态的协议。
无状态是指客户机（Web 浏览器）和服务器之间**不需要建立持久的**连接，这意味着当一个客户端向服务器端发出请求，然后服务器返回响应(response)，连接就被关闭了，在服务器端不保留连接的有关信息.HTTP 遵循**请求(Request)/应答(Response)模型**。客户机（浏览器）向服务器发送请求，服务器处理请求并返回适当的应答。**所有 HTTP 连接都被构造成一套请求和应答**。

#### 传输流程

1. **地址解析**：如用客户端浏览器请求这个页面：http://localhost.com:8080/index.htm 从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析结果如下：
   协议名：http
   主机名：localhost.com
   端口：8080
   对象路径：/index.htm
   在这一步，需要域名系统 DNS 解析域名 localhost.com,得主机的 IP 地址。
2. **封装 HTTP 请求数据包**：把以上部分结合本机自己的信息，封装成一个 HTTP 请求数据包。
3. **封装成 TCP 包并建立连接**：封装成 TCP 包，建立 TCP 连接（TCP 的三次握手）
4. **客户机发送请求命令**：建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是 MIME 信息包括请求修饰符、客户机信息内容。
5. **服务器响应**：服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是 MIME 信息包括服务器信息、实体信息和可能的内容。
6. **服务器关闭 TCP 连接**：一般情况下，一旦 Web 服务器向浏览器发送了请求数据，它就要关闭 TCP 连接，然后如果浏览器或者服务器在其头信息加入了这行代码 **Connection:keep-alive**，TCP 连接在发送后将仍然保持**打开状态**，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。

### HTTPS

#### ✉️ 概述

HTTPS简单讲是 HTTP 的安全版，即 HTTP 下加入 SSL 层，HTTPS 的安全基础是 SSL，其所用的端口号是 443。

SSL过程大致如下：

1. **建立连接获取证书**：SSL 客户端通过 TCP 和服务器建立连接之后（443 端口），并且在一般的 tcp 连接协商（握手）过程中请求证书。即**客户端**发出一个消息给**服务器**，这个消息里面包含了自己可实现的**算法列表**和其它一些需要的消息，**SSL 的服务器**端会回应一个数据包，这里面确定了这次通信所需要的算法，然后**服务器向客户端**返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。
2. **证书验证**：**客户端**在收到**服务器**返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，**客户端**还会确保证书中列出的域名就是它正在连接的域名。
3. **数据加密和传输**：如果确认证书有效，那么生成对称秘钥并使用**服务器**的公共秘钥进行加密。然后发送给**服务器**，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行**对称加密进行通信**。

### CDN

#### ✉️ 概述

内容分发网络（Content Delivery Network，CDN）通过将站点内容发布至遍布全球的海量加速节点，使其用户可就近获取所需内容，避免因网络拥堵、跨运营商、跨地域、跨境等因素带来的网络不稳定、访问延迟高等问题，有效提升下载速度、降低响应时间，提供流畅的用户体验。

#### 为什么需要CDN？

通常用户满意的网页打开时间是在2秒以下。互联网有一项著名的8秒原则。用户在访问Web网页时
，如果时间超过8秒就会感到不耐烦，如果下载需要太长时间，他们就会放弃访问。

**CDN的优势**

- CDN节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；
- 部分请求在CDN边缘节点完成，CDN起到了分流作用，减轻了源站的负载。

#### ✒️CDN的工作原理

传统的浏览器访问网站应步骤：

1. 在浏览器输入网址
2. 浏览器请求dns服务器，查询到对应的IP
3. 浏览器向服务器发起TCP连接
4. 浏览器通过建立的TCP连接发送HTTP协议报文
5. 服务器向浏览器发送页面内容
6. 浏览器将页面展现出来

**CDN用户访问流程：**

1. 用户向浏览器输入www.web.com这个域名，浏览器第一次发现本地没有dns缓存，则向网站的DNS服务器请求；
2. 网站的DNS域名解析器设置了CNAME，指向了www.web.51cdn.com,请求指向了CDN网络中的智能DNS负载均衡系统；
3. 智能DNS负载均衡系统解析域名，把对用户响应速度最快的IP节点返回给用户；
4. 用户向该IP节点（CDN服务器）发出请求；
5. 由于是第一次访问，CDN服务器会向原web站点请求，并缓存内容；
6. 请求结果发给用户。

CDN访问流程：
![CDN访问流程](https://raw.githubusercontent.com/qinguan1/qinguan1.github.io/main/docs/assets/img/qinguan/CDN访问流程.png)

#### CDN缓存

浏览器本地缓存失效后，浏览器会向CDN边缘节点发起请求。类似浏览器缓存，CDN边缘节点也存在着一套缓存机制。

#### CDN的缓存机制

CDN边缘节点缓存策略因服务商不同而不同，但一般都会遵循http标准协议，通过http响应头中的**Cache-control: max-age**的字段来设置CDN边缘节点数据缓存时间。

当客户端向CDN节点请求数据时，CDN节点会**判断缓存数据是否过期**，若缓存数据并没有过期，则直接将缓存数据返回给客户端；否则，CDN节点就会向源站发出回源请求，从源站拉取最新数据，更新本地缓存，并将**最新数据**返回给客户端。
所以，如果我们修改了内容，最好加个版本号，来容CDN**重新获取**资源，从而减少不必要的麻烦，
比如 : **app.js?v=20171114 或者 style.css?v=20171114**

#### CDN缓存刷新

CDN边缘节点对开发者是透明的，相比于浏览器 **Ctrl + F5** 的强制刷新来使浏览器本地缓存**失效**，开发者可以通过CDN服务商提供的“刷新缓存”接口来达到清理CDN边缘节点缓存的目的。这样开发者在更新数据后，可以使用“刷新缓存”功能来强制CDN节点上的数据**缓存过期**，保证客户端在访问时，拉取到**最新的数据**。
