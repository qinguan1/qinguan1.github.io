## java集合Map专题

作者：小路哥
<br/>博客：[https://bugstack.cn](https://bugstack.cn)

## 一、概述
Map是一种键-值对（key-value）集合，Map集合中的每一个元素都包含一个键对象和一个值对象。
Map接口规定了这类集合的基本雏形，也就是约定了向集合放入元素，从集合取元素，获取集合大小等待一系列方法，以及约定了key-value结构的
元素的接口Entry<K,V>，它的实现类必须实现此接口。
Map接口的实现主要有两类：HashMap类和TreeMap类。其中，HashMap类按哈希算法来存取键对象，而TreeMap类可以对键对象进行排序。

## 二、HashMap类
从线程安全角度来归类的话，可以分为线程安全类和非线程安全类
### 1. 非线程安全类
典型的代表就是HashMap，HashMap如果使用在多线程的场景下通常会出问题的。

### 2. 线程安全类

在Java发展的早期就在支持多线程了，所以也提供了一些线程安全的容器，比如在最早jdk1.2提供的集合容器类比如Vector、Hashtable，他们的实现机制都差不多，都是在方法层面上加synchronized关键字来实现线程安全。这种线程安全是以降低性能为代价的，时至今日Hashtable它的抽象父类Dictionary 已被提示为弃用

```java
/**
 * <strong>NOTE: This class is obsolete.  New implementations should
 * implement the Map interface, rather than extending this class.</strong>
 */
 public abstract
class Dictionary<K,V> {
    ...
}
```

所以 **Hashtable 一般是不被推荐使用的。**
在jdk1.5开始提供了多种并发容器用来改进同步容器的性能，比如用于替代 Hashtable 的同步容器 ConcurrentHashMap。
ConcurrentHashMap 是严格来说是线程安全版本的HashMap。
ConcurrentHashMap 被用来替代 Hashtable 肯定是解决了 Hashtable 的一些弊端，比如性能低下，主要体现在 synchronized 和底层的存储结构数组加链表，对于 Hashtable 而言，每一次对集合的操作都是串行的，它是会锁住整个 hash 表。
JDK1.7中的 ConcurrentHashMap 采用一种更加细粒度的 **“分段锁”** 加锁机制，将整张表分成了多个数组（Segment段），然后每个数组元素又是一个HashMap（hash表），加锁级别只在segment段上，segment继承了乐观锁ReentrantLock，这就意味着不同的segment段是不会锁冲突的，大大提升了并发性能。
当然了这种方式也有问题，缺点在于分成很多段时会比较浪费内存空间(不连续，碎片化); 操作 Map 时竞争同一个分段锁的概率非常小时，分段锁反而会造成更新等操作的长时间等待; 当某个段很大时，分段锁的性能会下降。
JDK1.8的实现已经摒弃了Segment的概念，或者说弱化了Segment，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，这里也涉及到关于Synchronized锁的优化，这个在另一个专题会详细讲解。

>**小贴士：** 
>**为什么不用ReentrantLock而用 synchronized ?**
>- 减少内存开销：如果使用ReentrantLock则需要节点继承AQS来获得同步支持，增加内存开销，而1.8中只有头节点需要进行同步。
>- 内部优化：synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。










## 三、TreeMap类

### 1. 非线程安全类



































































