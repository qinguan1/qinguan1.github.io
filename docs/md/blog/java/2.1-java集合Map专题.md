## java集合Map专题

作者：小路哥
<br/>博客：[https://bugstack.cn](https://bugstack.cn)

> 故不积跬步，无以至千里；不积小流，无以成江海！🌻

## 一、概述
Map是一种键-值对（key-value）集合，Map集合中的每一个元素都包含一个键对象和一个值对象。
Map接口规定了这类集合的基本雏形，也就是约定了向集合放入元素，从集合取元素，获取集合大小等待一系列方法，以及约定了key-value结构的
元素的接口Entry<K,V>，它的实现类必须实现此接口。
Map接口的实现主要有两类：HashMap类和TreeMap类。其中，HashMap类按哈希算法来存取键对象，而TreeMap类可以对键对象进行排序。

## 二、HashMap类

### 2.1 底层数据结构：

HashMap的底层数据在JDK 1.7版本是Table数组 + Entry链表，在JDK1.8版本是 Table数组 + Entry链表/红黑树；(为什么要使用红黑树？)

HashMap结构图：
![HashMap结构图](https://raw.githubusercontent.com/qinguan1/qinguan1.github.io/main/docs/assets/img/qinguan/HashMap结构图.png)

>**小贴士：**
- Java中，TreeMap、TreeSet都使用红黑树作为底层数据结构
- JDK1.8开始，HashMap也引入了红黑树：当冲突的链表长度超过8时，自动转为红黑树
- Linux底层的CFS进程调度算法中，vruntime使用红黑树进行存储。
- 多路复用技术的Epoll，其核心结构是红黑树 + 双向链表。

之所以是8，是因为Java的源码贡献者在进行大量实验发现，hash碰撞发生8次的概率已经降低到了0.00000006，几乎为不可能事件，如果真的碰撞发生了8次，那么这个时候说明由于元素本身和hash函数的原因，此次操作的hash碰撞的可能性非常大了，后序可能还会继续发生hash碰撞。所以，这个时候，就应该将链表转换为红黑树了，也就是为什么链表转红黑树的阈值是8。 最后，红黑树转链表的阈值为6，主要是因为，如果也将该阈值设置于8，那么当hash碰撞在8时，会反生链表和红黑树的不停相互激荡转换，白白浪费资源。


**后面的描述是基于JDK1.8**
### 2.2 初始化

负载因子0.75
负载因子的选择

### 2.2 放入元素

流程图

### 2.2 扩容

多线程的问题


>问题：
多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap

## 三、Hashtable类

在Java发展的早期就在支持多线程了，所以也提供了一些线程安全的容器，比如在最早jdk1.2提供的集合容器类比如Vector、Hashtable，他们的实现机制都差不多，都是在方法层面上加synchronized关键字来实现线程安全。这种线程安全是以降低性能为代价的，时至今日Hashtable它的抽象父类Dictionary 已被提示为弃用

```java
/**
 * <strong>NOTE: This class is obsolete.  New implementations should
 * implement the Map interface, rather than extending this class.</strong>
 */
 public abstract
class Dictionary<K,V> {
    ...
}
```

所以 **Hashtable 一般是不被推荐使用的。**

## 四、ConcurrentHashMap类

从jdk1.5开始提供了多种并发容器用来改进同步容器的性能，比如用于替代 Hashtable 的同步容器的ConcurrentHashMap。
ConcurrentHashMap 严格来说是线程安全版本的HashMap，被用来替代 Hashtable ，它的出现解决了 Hashtable 的一些弊端，比如性能低下，这方面主要体现在 Hashtable 的线程安全是基于 synchronized 关键字，早期的 synchronized 锁属于重量级锁，所以对于 Hashtable 而言，每一次对集合的操作都是串行的，它是会锁住整个 hash 表。
JDK1.7中的 ConcurrentHashMap 采用一种更加细粒度的 **“分段锁”** 加锁机制，将整张表分成了多个数组（Segment段），然后每个数组元素又是一个HashMap（hash表），加锁级别只在segment段上，segment继承了乐观锁ReentrantLock，这就意味着不同的segment段是不会锁冲突的，大大提升了并发性能。
当然了这种方式也有问题，缺点在于分成很多段时会比较浪费内存空间(不连续，碎片化); 操作 Map 时竞争同一个分段锁的概率非常小时，分段锁反而会造成更新等操作的长时间等待; 当某个段很大时，分段锁的性能会下降。
JDK1.8的实现已经摒弃了Segment的概念，或者说弱化了Segment，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，这里也涉及到关于Synchronized锁的优化，这个在另一个专题会详细讲解。

>**小贴士：为什么不用ReentrantLock而用 synchronized ?** 
>- 减少内存开销：如果使用ReentrantLock则需要节点继承AQS来获得同步支持，增加内存开销，而1.8中只有头节点需要进行同步。
>- 内部优化：synchronized则是JVM直接支持的，JVM能够在运行时作出相应的优化措施：锁粗化、锁消除、锁自旋等等。

**ConcurrentHashMap从JDK1.7到JDK1.8的区别汇总：**
- JDK1.8中新增了红黑树，提高了查询效率
- JDK1.7中使用的是头插法，JDK1.8中使用的是尾插法
- JDK1.7中使用了分段锁，而JDK1.8中没有使用分段锁了
- JDK1.7中使用了ReentrantLock，JDK1.8中没有使用ReentrantLock了，而使用了Synchronized
- JDK1.7中的扩容是每个Segment内部进行扩容，不会影响其他Segment，而JDK1.8中的扩容和HashMap的扩容类似，只不过支持了多线程扩容，并且保证了线程安全






## 五、TreeMap类




## 高频面试题部分





















































