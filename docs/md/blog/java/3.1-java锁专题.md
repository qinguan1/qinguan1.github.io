## java锁专题

作者：qinguan
<br/>博客：[https://bugstack.cn](https://bugstack.cn)

> 故不积跬步，无以至千里；不积小流，无以成江海！🌻

### 一、锁的分类
1. 从对待竞争的态度来分：乐观锁、悲观锁
2. 从抢锁的态度来分：公平锁、非公平锁
3. 从是否可重入来分：可重入锁，不可重入锁
4. 独享锁、共享锁
5. 互斥锁、读写锁
6. synchronized 锁升级(无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁) JDK1.6

### 二、内置锁：synchronized
在Java中，synchronized锁可能是我们最早接触的锁了，在 JDK1.5之前synchronized是一个重量级锁，相对于juc包中的Lock，synchronized显得比较笨重。
庆幸的是在 JDK1.6 之后 Java 官⽅对从 JVM 层⾯对synchronized进行⼤优化，所以现在的 synchronized 锁效率也优化得很不错。

#### 用法：
synchronized 关键字加到 static 静态方法和 synchronized(class) 代码块上都是是给 Class 类上锁。
synchronized 关键字加到实例方法上是给对象实例上锁。

#### Java对象结构
Java对象结构包括三部分：对象头、对象体和填充字节
java对象结构图：
![java对象结构图](https://raw.githubusercontent.com/qinguan1/qinguan1.github.io/main/docs/assets/img/qinguan/java对象结构.png)
#### synchronized锁升级：
锁升级(无锁 -> 偏向锁 -> 轻量级锁 -> 重量级锁) 

synchronized锁升级过程：
![synchronized锁升级](https://raw.githubusercontent.com/qinguan1/qinguan1.github.io/main/docs/assets/img/qinguan/synchronized锁升级过程.png)


### 三、逃逸分析 Escape Analysis

我们知道Java对象是在堆里分配的，在调用栈中，只保存了对象的指针。当对象不再使用后，需要依靠GC来遍历引用树并回收内存，如果对象数量较多，将给GC带来较大压力。因此，减少临时对象在堆内存分配的数量是最有效的优化方法。

#### 3.1 逃逸分为两种：
1. 方法逃逸：当一个对象在方法中被定义后，可能作为调用参数被外部方法说引用。
2. 线程逃逸：通过复制给类变量或者作为实例变量在其他线程中可以被访问到。

#### 3.2 逃逸分析相关优化：
如果证明一个对象不会逃逸方法外或者线程外，则可针对此变量进行一下三种优化：
1. 栈上分配stack allocation：如果对象不会逃逸到方法外，则对此对象在栈上分配内存，则对象所占用的空间可以随栈出栈而别销毁。
2. 同步消除synchronization Elimination：如果一个对象不会逃逸出线程，则对此变量的同步措施可消除。
3. Scalar replacement：标量scalar是不可再分解的量，比如基本数据类型，聚合量Aggregate是可以在被分解的，比如java中的对象。标量替换是将一个聚合量拆散，根据程序对此聚合量的访问情况，将其使用到的成员变量恢复到原始变量来访问就是标量替换。
**逃逸分析如果证明一个对象不会被外部访问，并且此对象可以被拆散，则程序执行时可能不会创建此对象。**

#### 3.3 参数开启
1. -XX:+DoEscapeAnalysis    开启逃逸分析；
2. -XX:+EliminateLocks  开启同步消除；
3. -XX:+EliminateAllocations    开启标量替换；
4. -XX:+PrintEscapeAnalysis 显示分析结果

#### 锁消除和锁粗化：


### 四、并发包：juc锁


### 五、分布式锁











